---
title: "The Val Object Model"
document: PXXXXXX
date: 2022-10-13
audience: Evolution
author:
  - name: Dave Abrahams
    email: <dabrahams@adobe.com>
  - name: Sean Parent
    email: <sparent@adobe.com>
  - name: Dimitri Racordon
    email: <dimitri.racordon@gmail.com>
  - name: David Sankel
    email: <dsankel@adobe.com>
toc: false
---

# Introduction

This paper presents a low-level programming model that is simple, powerful, efficient, and safe.  We
believe it could form the basis of a future safe dialect of C++.

# Motivation and Scope

Software safety is a growing and well-justified concern across government and industry, with a
recent [Linux foundation
plan](https://8112310.fs1.hubspotusercontent-na1.net/hubfs/8112310/OpenSSF/OSS%20Mobilization%20Plan.pdf)
specifically calling for “moving software away from C and C++ to safer languages.”  Until now,
creating memory safety in a language like C++ has meant the addition of hard-to-satisfy lifetime
annotation requirements that significantly increase API complexity.  As an alternative, we present
an object model—implemented in the [Val research language](https://www.val-lang.dev/)—based on value
semantics; an idea already deeply ingrained in C++.  It turns out that by “going
all in” on value semantics, we gain three things at once:

- Memory safety by construction
- Thread safety by construction (Rust's “fearless concurrency”)
- A simple and powerful programming model

As the C++ committee considers its response to the safety crisis, understanding the Val model could
allow us to arrive at a safer C++ that is also simpler.

# The Val Object Model

## Independence

The Val model starts by identifying **independence**—the idea that a mutation to one variable cannot
affect the value of another—as a key property of types with value semantics.  Independence is what
makes types like `int` easy to reason about and naturally safe for use with threads.  It is the true
source of the benefits functional programmers attribute to strict immutability (which can be viewed
as a costly way to achieve independence), and of Rust's “fearless concurrency.” 
C++'s support for independence of mutable user-defined types, can be traced back to Ada and Pascal,
but for 30 years during the OO revolution, new reference-based language designs flooded the scene
leaving C++ in a small club (along with Swift and Rust) of popular languages with first-class value
semantics.

C++ supports independence in three ways:

- Pass-by-value gives the callee an independent value.
- A returned value is independent in the caller (every rvalue is independent).
- Operations such as copying and assignment can be written to avoid sharing mutable state.

Unfortunately, C++ also *undermines* independence in two ways:

- Mutation occurs through a `this` pointer that can alias other reachable pointers and references.
- Pass-by-value eagerly copies parameters, causing programmers to reach for references to avoid
  costs.


- Details of the model
- Implications of the model

## Truly, no Reference Semantics?

```cpp
// Offsets x by delta.
template <class Numeric> void offset(Numeric& x, Numeric const& delta) {
  x += delta;
}

// Offsets x by 2*delta.
template <class Numeric> void offset2(Numeric& x, Numeric const& delta) {
  offset(x, delta);
  offset(x, delta);
}

void main() {
  auto x = 3;
  offset2(x, x);
  std::cout << x << std::endl;
}
```

# Comparison with the C++ Core Guidelines

The work most closely related to Val's object model in the landscape of C++ safety is Stroustrup and Sutter's C++ Core Guidelines [@CoreGuidelines].
This project compiles a large set of best practices to "use modern C++ effectively" and safely in the form of rules that can be enforced by a static analyzer.
The rules are organized into profiles designed to achieve a specific guarantee by construction.

A complete review of the rules defined by the C++ Core Guidelines is beyond the scope of this document.
Instead, we focus on the key principle the lifetime safety profile, which fends against uses of wild and dangling pointers.

## The lifetime profile in a nutshell

The central idea on which the lifetime safety profile builds is an ownership discpline to reason about the lifetime of an object.
An *owner* is an object that owns another object.
For example, an instance of `std::vector` owns the elements that it contains.
An owner is responsible for the destruction of its owned object(s) and, crucially, gets the guarantee that no other object can destroy those.

These two simple rules are sufficient to prevent a large class of errors.
To illustrate, consider the following program:

```cpp
void print_and_delete(int* p) {
  cout << *p << endl;
  delete p; // error
}

int main() {
  vector x = { 1, 2, 3 };
  print_and_delete(&x[1]);
}
```
 
This program is rejected under the lifetime safety profile, due to the call to `delete` in function `print_and_delete`.
Indeed, `p` is not an owner in this context and, therefore, is not allowed to delete the referred object.

An owner is also allowed to modify its owned object(s) in such a way that it may invalidate external references to them.
Consider the following example:

```cpp
int main() {
  vector x = { 1, 2, 3 };
  auto y = &x[1], z = &x[2];
  *z = x.size();      // OK
  x.clear();
  cout << *y << endl; // error
}
```

This program is rejected under the lifetime safety profile, due to the dereferencing of `y` after the call to `vector::clear`.
Because this method is a non-const member of `vector`, the analysis conservatively (here, rightly) assumes that it may invalidate non-owning references to `x`'s elements.
Note that a non-const member function may not change the contents of `x`, which explains why the dereferencing of `z` is not caught as an error.

To uphold these invalidation rules and keep the analysis intraprocedural, the core guidelines prescribe that references passed to a function be independent, unless annotated otherwise.
It follows that passing an owner as argument along with a reference into that owner's contents is caught as an error.
The rationale is that using the reference after the owner has been mutated may cause undefined behavior.
The following program illustrates such a situation:

```cpp
void resize_and_print(vector<int>& v, int const& u) {
  v.reserve(100);
  cout << u << endl;
}

int main() {
  vector x = { 1, 2, 3 };
  resize_and_print(x, x[1]); // error
}
```

This program is rejected under the lifetime safety profile, due to the call to `resize_and_print`.
Indeed, reallocating `x` would invalidate `x[1]` and thus cause undefined behavior when `u` gets dereferenced.

One of the objectives of the C++ Core Guidelines is to keep the annotation burden at a minimum.
Nonetheless, some C++ patterns do not fit the strict ownership discipline presented above, thus requiring user annotations to be guaranteed safe by a static analyzer.
Consider the following example:

```cpp
int main() {
  vector x = { 1, 2, 3 };
  auto position = x.end();
  x.insert(position, 4);
}
```

Because `vector::insert` is a non-const member function, the rules of the lifetime profile would reject this propgram due to `position` getting invalidated before it can be passed as an argument.
This conservative choice can be overridden by annotating `vector::insert` so that the iterator argument is known to be owned by `this`.

```cpp
template<class T, class Allocator = std::allocator<T>> class vector {
  constexpr iterator insert(const_iterator pos, const T& value)
    [[gsl::pre(pos, lifetime({this}))]];
  ...
}
```

A number of other annotations can be used to override default conservative choices and support more elaborated patterns.
We refer the interested reader to [@P1179R0] for the complete specification.

## Similarities and differences with Val's model

The concept of ownership in the C++ Core Guidelines strongly relates to the notions of value independence and whole/part relationships in Val.
For example, a vector (i.e., a dynamic array in Val parlance parlance) is naturally a composition of its elements, which denotes its parts.
A whole is responsible for the lifetime of its parts, just like an owner is responsible for that of its owned objects.
Further, mutating a whole requires its independence, just like passing an owner as an argument prevents references to its contents to be passed simultaneously.

Since Val does not support first-class pointers and references, reasoning about whole/part relationships is sufficient to achieve the same expressiveness as the approach adovcated by the C++ Core Guidelines, without any annotation.
Indeed, if `s` is a part of `t`, then naturally the lifetime of `s` is necessarily bound by that of `t`, and modifying `t` may invalidate `s`.

The definition of a whole is unambiguous in a world governed by mutable value semantics.
In constrast, the definition of an owner in a world of references is ad-hoc.
Hence, it incumbs to the user to teach the compiler or static analyzer about the distinctions between owners and non-owners, and about the parts that belong to a specific owner type.
Since this information is not defined intrinsically, one must resort to annotations.

# Conclusion

- Not necessarily the answer for C++
- Syntax doesn't matter for C++

---
references:
  - id: CoreGuidelines
    citation-label: CoreGuidelines
    title: "C++ Core Guidelines"
    author:
      - family: Stroustrup
        given: Bjarne
      - family: Sutter
        given: Herb
    issued:
      year: 2022
    URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
  - id: P1179R0
    citation-label: P1179R0
    title: "Lifetime safety: Preventing common dangling"
    author:
      family: Sutter
      given: Herb
    issued:
      year: 2018
    URL: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1179r0.pdf
---
