---
title: "The Val Object Model"
document: PXXXXXX
date: 2022-10-13
audience: Evolution
author:
  - name: Dave Abrahams
    email: <dabrahams@adobe.com>
  - name: Sean Parent
    email: <sparent@adobe.com>
  - name: Dimitri Racordon
    email: <dimitri.racordon@gmail.com>
  - name: David Sankel
    email: <dsankel@adobe.com>
toc: false
---

# Introduction

This paper presents a low-level programming model that is simple, powerful, efficient, and safe.  We
believe it could form the basis of a future safe dialect of C++.

# Motivation and Scope

Software safety is a growing and well-justified concern across government and industry, with a
recent [Linux foundation
plan](https://8112310.fs1.hubspotusercontent-na1.net/hubfs/8112310/OpenSSF/OSS%20Mobilization%20Plan.pdf)
specifically calling for “moving software away from C and C++ to safer languages.”  Until now,
acheiving memory safety in a language like C++ has meant the use of impractical whole-program
analysis or the addition of hard-to-satisfy lifetime annotation requirements that significantly
increase API complexity.  As an alternative, we present an object model—implemented in the [Val
research language](https://www.val-lang.dev/)—based on value semantics; an idea already deeply
ingrained in C++.  It turns out that by “going all in” on value semantics, we gain three things at
once:

- Memory safety by construction
- Thread safety by construction (Rust's “fearless concurrency”)
- A simple and powerful programming model

As the C++ committee considers its response to the safety crisis, understanding the Val model could
allow us to arrive at a safer C++ that is also simpler.

# The Val Object Model

## Independence

The Val model starts by identifying **independence**—the idea that a mutation to one variable cannot
affect the value of another—as a key property of types with value semantics.  Independence is what
makes types like `int` easy to reason about and naturally safe for use with threads.  It is the true
source of the benefits functional programmers attribute to strict immutability (which can be viewed
as a costly way to achieve independence), and of Rust's “fearless concurrency.” 
C++'s support for independence of mutable user-defined types, can be traced back to Ada and Pascal,
but for 30 years during the OO revolution, new reference-based language designs flooded the scene
leaving C++ in a small club (along with Swift and Rust) of popular languages with first-class value
semantics.

C++ supports independence in three ways:

- Pass-by-value gives the callee an independent value.
- A returned value is independent in the caller (every rvalue is independent).
- Operations such as copying and assignment can be written to avoid sharing mutable state.

Unfortunately, C++ also *undermines* independence:

- Mutation occurs through a `this` pointer that can alias other reachable pointers and references.
- Pass-by-value eagerly copies parameters, so programmers use references as a substitute.

## The Implied Contract for References

The use of pass-by-`const&` to mean “pass-by-value; just do it efficiently” is so ingrained in C++
practice that we do it automatically, even though it affects semantics:

::: cmptable

### Before 

```cpp
// Offsets x by 2*delta.
void offset2(BigNum& x, BigNum delta) {
  x += delta
  x += delta
}

void main() {
  BigNum x = 3;
  offset2(x, x);
  std::cout << x << std::endl; // Prints 9
}
```

### After 

```cpp
// Offsets x by 2*delta.
void offset2(BigNum& x, BigNum const& delta) {
  x += delta
  x += delta
}

void main() {
  BigNum x = 3;
  offset2(x, x);
  std::cout << x << std::endl; // Prints 12
}
```

:::

The only reasonable way to make the *After* code correct is to add an aditional independence
requirement, and hope that users uphold it.

```cpp
// Offsets x by 2*delta. Requires: x and delta are distinct objects.
void offset2(BigNum& x, BigNum const& delta) {
  x += delta
  x += delta
}

void main() {
  BigNum x = 3;
  offset2(x, BigNum(x));  // Note explicit copy
  std::cout << x << std::endl; // Prints 9
}
```

Of course, independence requirements are almost never stated explicitly: in practice, there is a
**Law of Exclusivity** [@SE-0176], which requires the values of any object denoted by a mutable
reference to be independent of the values of all other variables.  We claim this law is built into
every C++ programmer's mental model, because there is no other rational way to deal with mutation.

In fact, the semantics of a mutating function is nearly impossible to describe unless the Law is
upheld.  The C++ standard library specification demonstrates. Looking through the standard with the
Law in mind, it is easy to find cases like this one, which is required to work by the standard, but
can't possibly do so and causes undefined behavior in practice
([godbolt](https://godbolt.org/z/xKq3onTj3)):

```cpp
#include <algorithm>
#include <vector>

int main() {
  std::vector v = { 0, 1 };
  std::ranges::sort(v, [&](int x, int y){ v.push_back(2); return y < x; });
}
```

Or this one, which is also allowed, with behavior that is at best implicitly unspecified
([godbolt](https://godbolt.org/z/vnn49YTqb)):

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector v = { 0, 1, 2, 1, 2, 1, 2 };
  std::ranges::replace(v, v[1], v[2]);
  for (auto x: v) { std::cout << x; } // What output do you expect?
}
```

This despite the fact that the standard bans a variety of *specific violations*
(e.g. [algorithms.requirements]{.sref}/[7](https://wg21.link/algorithms.requirements#7),
[sequence.reqmts]{.sref}/[37](https://wg21.link/sequence.reqmts#37)) of the Law, as a result of
discoveries made over the course of two decades.

# Comparison with the C++ Core Guidelines

The work most closely related to Val's object model in the landscape of C++ safety is Stroustrup and Sutter's C++ Core Guidelines [@CoreGuidelines].
This project compiles a large set of best practices to "use modern C++ effectively" and safely in the form of rules that can be enforced by a static analyzer.
The rules are organized into profiles designed to achieve a specific guarantee by construction.

A complete review of the rules defined by the C++ Core Guidelines is beyond the scope of this document.
Instead, we focus on the key principle the lifetime safety profile, which fends against uses of wild and dangling pointers.

## The lifetime profile in a nutshell

The central idea on which the lifetime safety profile builds is an ownership discpline to reason about the lifetime of an object.
An *owner* is an object that owns another object.
For example, an instance of `std::vector` owns the elements that it contains.
An owner is responsible for the destruction of its owned object(s) and, crucially, gets the guarantee that no other object can destroy those.

These two simple rules are sufficient to prevent a large class of errors.
To illustrate, consider the following program:

```cpp
void print_and_delete(int* p) {
  cout << *p << endl;
  delete p; // error
}

int main() {
  vector x = { 1, 2, 3 };
  print_and_delete(&x[1]);
}
```
 
This program is rejected under the lifetime safety profile, due to the call to `delete` in function `print_and_delete`.
Indeed, `p` is not an owner in this context and, therefore, is not allowed to delete the referred object.

An owner is also allowed to modify its owned object(s) in such a way that it may invalidate external references to them.
Consider the following example:

```cpp
int main() {
  vector x = { 1, 2, 3 };
  auto y = &x[1], z = &x[2];
  *z = x.size();      // OK
  x.clear();
  cout << *y << endl; // error
}
```

This program is rejected under the lifetime safety profile, due to the dereferencing of `y` after the call to `vector::clear`.
Because this method is a non-const member of `vector`, the analysis conservatively (here, rightly) assumes that it may invalidate non-owning references to `x`'s elements.
Note that a non-const member function may not change the contents of `x`, which explains why the dereferencing of `z` is not caught as an error.

To uphold these invalidation rules and keep the analysis intraprocedural, the core guidelines prescribe that references passed to a function be independent, unless annotated otherwise.
It follows that passing an owner as argument along with a reference into that owner's contents is caught as an error.
The rationale is that using the reference after the owner has been mutated may cause undefined behavior.
The following program illustrates such a situation:

```cpp
void resize_and_print(vector<int>& v, int const& u) {
  v.reserve(100);
  cout << u << endl;
}

int main() {
  vector x = { 1, 2, 3 };
  resize_and_print(x, x[1]); // error
}
```

This program is rejected under the lifetime safety profile, due to the call to `resize_and_print`.
Indeed, reallocating `x` would invalidate `x[1]` and thus cause undefined behavior when `u` gets dereferenced.

One of the objectives of the C++ Core Guidelines is to keep the annotation burden at a minimum.
To that end, rules have carefully designed default that correspond to most valid use of modern C++.
The patterns that do not fit to these defaults can be expressed by user annotations.
We refer the interested reader to [@P1179R0] for the complete specification.

## Correspondance to Val

The concept of ownership in the C++ Core Guidelines strongly relates to the notions of value independence and whole/part relationships in Val.
For example, a vector (i.e., a dynamic array in Val parlance parlance) is naturally a composition of its elements, which denotes its parts.
A whole is responsible for the lifetime of its parts, just like an owner is responsible for that of its owned objects.
Further, mutating a whole requires its independence, just like passing an owner as an argument prevents references to its contents to be passed simultaneously.

Without first-class pointers and references, reasoning about whole/part relationships is sufficient to achieve the similar expressiveness as the approach adovcated by the C++ Core Guidelines.
Indeed, if `s` is a part of `t`, then naturally the lifetime of `s` is necessarily bound by that of `t`, and modifying `t` may invalidate `s`.

The definition of a whole is unambiguous in a world governed by mutable value semantics.
In contrast, the definition of an owner in a world of references is ad-hoc.
Hence, it incumbs to the user to teach the compiler or static analyzer about the distinctions between owners and non-owners, and about the parts that belong to a specific owner type.
While the category to which a type belongs might be sometimes infer, other cases must resort to annotations.

Although the C++ Core Guidelines do not claim complete memory safety and do not address thread safety yet, the authors are confident it can reach these goals through iterative refinements.
This assumption is justified by the fact that the lifetime profile takes the same path as the Rust programming language, which already offers statically guaranteed memory and thread safety by construction.

We also note that both Rust and Val offers an escape hatch to execute unsafe operations.
These escape hatches correspond to the `[gsl::suppress(tag)]]` annotation, which lets one explicitly silence specific rules from the C++ Core Guidelines.
Hence, both Rust and Val are as expressive as C++ if we consider their respective unsafe subsets.

Using Rust as a proxy for a future more complete version of the lifetime profile, we can draw conclusions about the expressiveness of Val's model with respect to that of the C++ Core Guidelines.
Val's safe subset is almost as expressive as Rust's.
The difference lies in the fact that one cannot reassign a binding or remote part (i.e., a reference in Rust) to a different object.
This limitation has very little impact in practice.

# Conclusion

- Not necessarily the answer for C++
- Syntax doesn't matter for C++

---
references:
  - id: CoreGuidelines
    citation-label: CoreGuidelines
    title: "C++ Core Guidelines"
    author:
      - family: Stroustrup
        given: Bjarne
      - family: Sutter
        given: Herb
    issued:
      year: 2022
    URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
  - id: P1179R0
    citation-label: P1179R0
    title: "Lifetime safety: Preventing common dangling"
    author:
      family: Sutter
      given: Herb
    issued:
      year: 2018
    URL: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1179r0.pdf
  - id: SE-0176
    citation-label: SE-0176
    title: "Enforce Exclusive Access to Memory"
    author:
      family: McCall
      given: John
    issued:
      year: 2017
---
