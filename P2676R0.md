---
title: "The Val Object Model"
document: PXXXXXX
date: 2022-10-13
audience: Evolution
author:
  - name: Dave Abrahams
    email: <dabrahams@adobe.com>
  - name: Sean Parent
    email: <sparent@adobe.com>
  - name: Dimitri Racordon
    email: <dimitri.racordon@gmail.com>
  - name: David Sankel
    email: <dsankel@adobe.com>
toc: false
---

# Introduction

This paper presents a low-level programming model that is simple, powerful, efficient, and safe.  We
believe it could form the basis of a future safe dialect of C++.

# Motivation and Scope

Software safety is a growing and well-justified concern across government and industry, with a
recent [Linux foundation
plan](https://8112310.fs1.hubspotusercontent-na1.net/hubfs/8112310/OpenSSF/OSS%20Mobilization%20Plan.pdf)
specifically calling for “moving software away from C and C++ to safer languages.”  Until now,
creating memory safety in a language like C++ has meant the addition of hard-to-satisfy lifetime
annotation requirements that significantly increase API complexity.  As an alternative, we present
an object model—implemented in the [Val research language](https://www.val-lang.dev/)—based on value
semantics; an idea already deeply ingrained in C++.  It turns out that by “going
all in” on value semantics, we gain three things at once:

- Memory safety by construction
- Thread safety by construction (Rust's “fearless concurrency”)
- A simple and powerful programming model

As the C++ committee considers its response to the safety crisis, understanding the Val model could
allow us to arrive at a safer C++ that is also simpler.

# The Val Object Model

- Details of the model
- Implications of the model

# Comparison with the C++ Core Guidelines

The work most closely related to Val's object model in the landscape of C++ safety is Stroustrup and Sutter's C++ Core Guidelines [@CoreGuidelines].
This project compiles a large set of best practices to "use modern C++ effectively" and safely in the form of rules that can be enforced by a static analyzer.
The rules are organized into profiles designed to achieve a specific guarantee by construction.

A complete review of the rules defined by the C++ Core Guidelines is beyond the scope of this document.
Instead, we focus on the key principle the lifetime safety profile, which fends against uses of wild and dangling pointers.

## The lifetime profile in a nutshell

The central idea on which the lifetime safety profile builds is an ownership discpline to reason about the lifetime of an object.
An *owner* is an object that owns another object.
For example, an instance of `std::vector` owns the elements that it contains.
An owner is responsible for the destruction of its owned object(s) and, crucially, gets the guarantee that no other object can destroy those.

These two simple rules are sufficient to prevent a large class of errors.
To illustrate, consider the following program:

```cpp
void print_and_delete(int* p) {
  cout << *p << endl;
  delete p; // error
}

int main() {
  vector x = { 1, 2, 3 };
  print_and_delete(&x[1]);
}
```
 
This program is rejected under the lifetime safety profile, due to the call to `delete` in function `print_and_delete`.
Indeed, `p` is not an owner in this context and, therefore, is not allowed to delete the referred object.

An owner is also allowed to modify its owned object(s) in such a way that it may invalidate external references to them.
Consider the following example:

```cpp
int main() {
  vector x = { 1, 2, 3 };
  auto y = &x[1], z = &x[2];
  *z = x.size();      // OK
  x.clear();
  cout << *y << endl; // error
}
```

This program is rejected under the lifetime safety profile, due to the dereferencing of `y` after the call to `vector::clear`.
Because this method is a non-const member of `vector`, the analysis conservatively (here, rightly) assumes that it may invalidate non-owning references to `x`'s elements.
Note that a non-const member function may not change the contents of `x`, which explains why the dereferencing of `z` is not caught as an error.

To uphold these invalidation rules and keep the analysis intraprocedural, the core guidelines prescribe that references passed to a function be independent, unless annotated otherwise.
It follows that passing an owner as argument along with a reference into that owner's contents is caught as an error.
The rationale is that using the reference after the owner has been mutated may cause undefined behavior.
The following program illustrates such a situation:

```cpp
void resize_and_print(vector<int>& v, int const& u) {
  v.reserve(100);
  cout << u << endl;
}

int main() {
  vector x = { 1, 2, 3 };
  resize_and_print(x, x[1]); // error
}
```

This program is rejected under the lifetime safety profile, due to the call to `resize_and_print`.
Indeed, reallocating `x` would invalidate `x[1]` and thus cause undefined behavior when `u` gets dereferenced.

This strict ownership discipline can express a significant subset of modern C++ idioms.
However, ...

## Correspondence to Val's model

The concept of ownership in the C++ Core Guidelines strongly relates to the notions of value independence and whole/part relationships in Val.
For example, a dynamic array (i.e., a vector in C++ parlance) in Val is naturally a composition of its elements, which denote its parts.

A whole is responsible for the lifetime of its parts, just like an owner is responsible for that of its owned objects.
Further, mutating a whole requires its independence, just like passing an owner as an argument prevents references to its contents to be passed simultaneously.

- Definition of what an owner is is ad-hoc.
- Val recognizes whole-part relationships.

# Conclusion

- Not necessarily the answer for C++
- Syntax doesn't matter for C++

---
references:
  - id: CoreGuidelines
    citation-label: CoreGuidelines
    title: "C++ Core Guidelines"
    author:
      - family: Stroustrup
        given: Bjarne
      - family: Sutter
        given: Herb
    issued:
      year: 2022
    URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
---
